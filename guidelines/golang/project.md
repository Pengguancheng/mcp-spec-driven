# Golang 微服务开发规范

本文档提供了 Golang 微服务开发的规范和最佳实践，包括目录结构、命名规则、包引用关系等方面的指导。

## 概述

本规范旨在提供一套一致的开发标准，帮助团队成员编写高质量、可维护的微服务代码。遵循这些规范可以：

- 提高代码质量和可维护性
- 减少开发过程中的常见错误
- 促进团队协作和知识共享
- 加速新成员的入职和学习
- 确保系统的可扩展性和可靠性

## 如何使用本规范

1. 新项目启动：在启动新项目时，参考目录结构和包引用关系设计项目架构
2. 代码编写：遵循命名规则和各组件的实现指南编写代码
3. 代码审查：使用最佳实践作为代码审查的参考标准

## 规范更新

本规范将根据项目需求和团队反馈持续更新。如有建议或问题，请通过以下方式提出：

1. 提交 Issue 或 Pull Request
2. 在团队会议中讨论
3. 直接联系规范维护者

## 参考资源

- Effective Go
- Go Code Review Comments
- Standard Go Project Layout
- Clean Architecture
- Domain-Driven Design

## 1. 目录结构

### 标准目录结构

```
/project-name/
├── app/                  # 应用上下文和初始化
│   └── ctx.go            # 定义应用依赖注入与全局上下文
├── applibs/              # 通用应用库与基础设施组件
│   ├── dispatch.go       # 事件分发处理
│   └── rmq.go            # 消息队列封装
├── config/               # 配置文件与常量定义
│   ├── const.go          # 全局常量
│   └── json_config.go    # JSON配置加载
├── domain/               # 领域模型和接口定义（领域驱动设计核心）
│   ├── model/            # 领域实体与值对象
│   └── repository/       # 仓储接口定义
├── handler/              # 事件处理器
│   └── handler_{event}/  # 按事件类型组织的处理器
├── persistent/           # 仓储实现层
│   └── persistent_{db}/  # 按数据库类型组织的实现
├── procedure/            # 业务流程与用例实现
│   └── pro_{domain}/     # 按领域组织的业务流程
├── proto/                # 协议缓冲定义
│   ├── event_{domain}/   # 领域事件定义
│   └── proto_{service}/  # 服务接口定义
└── proto_service/        # 协议服务实现
    └── {service}.go      # 具体服务实现
```

### 目录职责说明

- app/: 应用启动、配置和上下文管理
- applibs/: 独立于业务逻辑的通用基础设施代码
- config/: 集中管理配置信息
- domain/: 核心业务模型与接口定义
- handler/: 事件处理程序
- persistent/: 持久化实现
- procedure/: 业务流程实现
- proto/: 服务间通信协议定义
- proto_service/: gRPC 服务具体实现

## 2. 命名规则

### 包命名

- 使用小写单词，不使用下划线或驼峰命名
- 包名应简洁且能表达其内容
- 示例：`model`, `repository`, `persistent_mongo`

### 文件命名

- 使用小写单词，可使用下划线分隔
- 文件名应反映其主要内容
- 示例：`overview.go`, `overview_summary.go`, `handler_symbolTaskFinish.go`

### 结构体命名

- 使用大驼峰命名法（PascalCase）
- 示例：`Overview`, `OverviewSummary`, `SymbolTaskFinishedEventHandler`

### 接口命名

- 使用大驼峰命名法
- 通常以功能命名，而不是以 "I" 前缀
- 示例：`OverviewRepository`, `OverviewSummaryRepository`

### 方法命名

- 使用大驼峰命名法
- 动词开头，清晰表达功能
- 示例：`FindById`, `UpsertBatch`, `DeleteAll`

### 变量命名

- 使用小驼峰命名法（camelCase）
- JSON 标签使用小驼峰；MongoDB 标签使用下划线命名法（snake_case）
- 示例：

```
Id string `json:"id" bson:"_id"`
ProfitPercent float64 `json:"profitPercent" bson:"profit_percent"`
```

### 过程命名

- 过程结构体以 `Pro` 前缀命名
- 示例：`ProSummary`, `ProFlush`, `ProGetOverviewData`

## 3. 包之间的参考关系

为避免循环依赖，应遵循自上而下的依赖方向：

```
app → applibs, persistent, proto_service, handler
     ↑
handler → app, procedure, proto
     ↑
procedure → domain, proto
     ↑
persistent → domain
     ↑
proto_service → domain, persistent
     ↑
domain (最底层，不依赖其他包)
```

### 依赖规则

1. 领域层（domain）是最基础的层，不依赖其他层
2. 持久化层（persistent）只依赖领域层
3. 过程层（procedure）依赖领域层和协议层
4. 处理器层（handler）依赖应用层、过程层和协议层
5. 应用层（app）可以依赖所有其他层，作为组装的入口

### 依赖方向

- 依赖应该始终从高层指向低层
- 避免循环依赖
- 使用接口隔离不同层之间的依赖
- 领域层作为核心层，不应该依赖任何其他层

## 4. 领域模型

领域模型是业务实体的抽象表示，位于 `domain/model` 目录。

### 模型定义规范

- 模型应仅承载数据结构与基础校验，不嵌入业务流程逻辑
- 与 Proto 互转时，提供清晰、可测试的转换函数（实现细节不在规范中展开）

### 最佳实践

1. 模型应该是纯粹的数据结构，不包含业务逻辑
2. 使用适当的标签来支持序列化和反序列化
3. 提供清晰的转换方法，确保数据一致性
4. 遵循命名规范，确保字段名称的一致性
5. 为复杂模型提供构造函数或工厂方法

## 5. 领域仓储

领域仓储接口定义了对领域模型的持久化操作，位于 `domain/repository` 目录。

### 接口定义规范

- 在领域层定义接口，在持久化层提供实现
- 接口仅体现领域语义，避免泄漏底层数据库细节

### 接口方法命名规范

- 查询方法：以 `Find`, `Get`, `Query` 开头
    - `FindById(id string) (*model.Entity, error)`
    - `FindAll() ([]*model.Entity, error)`
    - `FindByField(value string) ([]*model.Entity, error)`
- 更新方法：以 `Update`, `Upsert`, `Save` 开头
    - `Update(entity *model.Entity) error`
    - `UpsertBatch(entities []*model.Entity) error`
    - `Save(entity *model.Entity) error`
- 删除方法：以 `Delete`, `Remove` 开头
    - `DeleteById(id string) error`
    - `DeleteAll() error`
    - `DeleteByField(value string) error`

### 最佳实践

1. 接口应该定义在领域层，实现在持久化层
2. 方法命名应清晰表达其功能和参数
3. 返回适当的错误信息，不要吞掉错误
4. 接口方法应该是原子操作
5. 复杂查询应该有明确的方法名和参数
6. 批量操作应该提供事务支持
7. 避免在接口中暴露底层数据库细节

## 6. 配置管理

配置处理位于 `config` 目录，负责加载和管理应用配置。

### 配置结构与加载

- 使用结构化配置承载应用参数，依环境加载分离的配置文件（如 `config.develop.json`、`config.prod.json`）
- 配置读取、解析与校验逻辑应集中、可测试，避免分散于业务代码

### 配置文件分离

- `config.develop.json` - 开发环境
- `config.prod.json` - 生产环境

### 常量定义

- 系统与业务常量集中管理，命名清晰，按功能分组

### 最佳实践

1. 所有环境相关配置均应外部化，不要硬编码
2. 使用结构化配置，便于类型检查和自动补全
3. 提供默认值，确保应用在配置缺失时仍能正常运行
4. 敏感信息（如密码、密钥）应通过环境变量或安全存储提供
5. 配置加载失败应提供明确的错误信息
6. 配置结构应有清晰的文档说明每个字段的用途
7. 常量应按功能分组，并提供有意义的名称

## 7. 应用库

应用库提供通用功能和工具，位于 `applibs` 目录。这些库独立于业务逻辑，提供基础设施支持。

### 消息队列封装 / 事件分发 / 日志工具

- 统一封装外部依赖（MQ、日志、分发器等），暴露稳定接口；实现细节不在规范中展开

### 最佳实践

1. 应用库应该是无状态的，便于测试和复用
2. 提供清晰的错误处理和日志记录
3. 使用依赖注入传递上下文和配置
4. 避免在应用库中包含业务逻辑
5. 为复杂操作提供重试和熔断机制
6. 使用接口隔离外部依赖，便于模拟测试
7. 提供合理的默认值和配置选项

## 8. 应用上下文

应用上下文整合了应用的各个组件，位于 `app` 目录。上下文作为依赖注入的容器，管理应用的生命周期和依赖关系。

### 上下文结构/创建/关闭

- 上下文集中承载依赖的声明、初始化与释放；代码示例从规范中移除，仅保留原则

### 最佳实践

1. 上下文应该包含所有应用依赖，避免使用全局变量
2. 使用构造函数创建上下文，确保所有依赖正确初始化
3. 提供关闭方法，确保资源正确释放
4. 使用接口而非具体实现，便于测试和替换
5. 错误处理应该清晰明确，避免部分初始化的上下文
6. 避免在上下文中包含业务逻辑
7. 上下文应该是线程安全的，可以在多个 goroutine 中使用

## 10. 事件处理器

处理器负责处理事件，位于 `handler` 目录。每个处理器只处理一种类型的事件，遵循单一职责原则。

### 处理器结构/命名/注册

- 每个处理器单一职责；以事件语义命名；注册集中管理

### 最佳实践

1. 每个处理器只处理一种类型的事件
2. 处理器应该是无状态的，通过上下文获取依赖
3. 处理器应该将业务逻辑委托给过程层，自身只负责事件解析和调用
4. 处理器应该记录详细的日志，便于问题排查
5. 处理器应该处理所有可能的错误，避免崩溃
6. 处理器应该验证事件数据的有效性
7. 处理器应该有明确的命名，表明其处理的事件类型

## 11. 持久化实现

MongoDB（或其他存储）持久化实现位于 `persistent/persistent_{db}` 目录，负责实现领域仓储接口。

### 仓储结构/创建

- 按数据库特性进行索引与生命周期管理；实现细节从规范中移除

### 最佳实践

1. 显式管理索引与唯一约束，保障数据一致性
2. 读写分离（如适用），避免热点瓶颈
3. 数据模型与领域模型解耦，进行必要的映射
4. 严格处理错误并返回可操作的信息
5. 关键路径中避免 N+1、提供批量接口

## 12. 过程流程

过程用于组织可复用的业务步骤，位于 `procedure` 目录。

### 过程组合

- 过程应可组合、可复用，支持串联/编排；实现细节从规范中移除

### 最佳实践

1. 过程应该是无状态的，通过上下文传递数据
2. 过程应该有明确的职责，遵循单一职责原则
3. 过程应该可组合，支持复杂业务流程的构建
4. 过程应该处理所有可能的错误，提供清晰的错误信息
5. 过程应该记录关键操作的日志
6. 过程应该验证输入参数的有效性
7. 过程可以发布事件，但不应该直接处理事件

## 13. 协议缓冲

协议缓冲定义位于 `proto` 目录，包括消息定义、服务定义和事件定义。

### 消息/服务/事件/实现

- 仅保留设计约束：消息命名清晰、字段语义明确；服务接口遵循单一职责；事件有稳定的名称与版本；服务实现遵循依赖注入与错误处理规范。具体样例从规范中移除

